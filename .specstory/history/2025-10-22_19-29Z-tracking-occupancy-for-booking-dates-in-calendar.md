<!-- Generated by SpecStory -->

<!-- vscode Session adff2099-e5b6-4048-b25e-2d59bd93c03a (2025-10-22 19:29Z) -->

# Tracking occupancy for booking dates in calendar (2025-10-22 19:29Z)

_**User (2025-10-22 19:32Z)**_

Now I need to be able to track how many people are booked for a given date. I am thinking using invoicing_items to count number of persons, for that I need to add category to invoicing_items to separate people from extras added to invoice. Then I would love to show it in calendar, for every displayed day show number of totally book ed people in the cottage. So I can easily see how much space I still have. Does it make sense? How would you approach this. Ask any additional questions

---

_**Assistant (copilot/claude-sonnet-4.5)**_

Your approach makes sense! Let me clarify a few things to provide the best solution:

## Questions:

1. **Category vs. Item Type**: Would you prefer a simple category field (e.g., `"person"`, `"extra"`) or a more flexible `item_type` enum? This would help filter people-related items from extras like amenities or services.

2. **Occupancy Calculation**: Should the occupancy count include:
   - Only adults?
   - Adults + kids (both age groups)?
   - Different weighting (e.g., kids under 2 don't count toward capacity)?

3. **Capacity Limits**: Do you have a total cottage capacity you want to track against? This would help show "X/Y people booked" or color-code days (green = plenty of space, yellow = getting full, red = at capacity).

4. **Calendar Display**: Should the calendar show:
   - Just the total count per day (e.g., "12 people")?
   - Breakdown by booking (e.g., "Booking A: 4, Booking B: 3")?
   - Visual indicator (color coding, progress bar)?

## Suggested Approach:

````elixir
defmodule CozyCheckout.Repo.Migrations.AddItemTypeToBookingInvoiceItems do
  use Ecto.Migration

  def change do
    alter table(:booking_invoice_items) do
      add :item_type, :string, default: "person", null: false
    end

    create index(:booking_invoice_items, [:item_type])
  end
end
````

````elixir
# ...existing code...

schema "booking_invoice_items" do
  field :name, :string
  field :quantity, :integer
  field :price_per_night, :decimal
  field :vat_rate, :decimal
  field :item_type, :string, default: "person"

  # ...existing code...
end

@doc false
def changeset(invoice_item, attrs) do
  invoice_item
  |> cast(attrs, [
    :booking_invoice_id,
    :name,
    :quantity,
    :price_per_night,
    :vat_rate,
    :subtotal,
    :vat_amount,
    :total,
    :position,
    :item_type
  ])
  |> validate_required([:name, :quantity, :price_per_night, :vat_rate, :item_type])
  |> validate_inclusion(:item_type, ["person", "extra"])
  # ...existing code...
end
````

Then add a context function to calculate daily occupancy:

````elixir
# ...existing code...

@doc """
Returns the total number of people booked for a specific date.
"""
def get_occupancy_for_date(date) do
  from(b in Booking,
    join: bi in BookingInvoice, on: bi.booking_id == b.id,
    join: bii in BookingInvoiceItem, on: bii.booking_invoice_id == bi.id,
    where: b.status in ["upcoming", "active"],
    where: b.check_in_date <= ^date,
    where: is_nil(b.check_out_date) or b.check_out_date > ^date,
    where: bii.item_type == "person",
    select: sum(bii.quantity)
  )
  |> Repo.one()
  |> case do
    nil -> 0
    count -> count
  end
end

@doc """
Returns daily occupancy for a date range (for calendar view).
Returns a map: %{~D[2025-10-22] => 12, ~D[2025-10-23] => 15, ...}
"""
def get_occupancy_for_range(start_date, end_date) do
  # Get all bookings that overlap with the date range
  bookings = from(b in Booking,
    join: bi in BookingInvoice, on: bi.booking_id == b.id,
    join: bii in BookingInvoiceItem, on: bii.booking_invoice_id == bi.id,
    where: b.status in ["upcoming", "active"],
    where: b.check_in_date <= ^end_date,
    where: is_nil(b.check_out_date) or b.check_out_date > ^start_date,
    where: bii.item_type == "person",
    select: %{check_in: b.check_in_date, check_out: b.check_out_date, quantity: bii.quantity},
    preload: []
  )
  |> Repo.all()

  # Calculate occupancy for each day
  Date.range(start_date, end_date)
  |> Enum.map(fn date ->
    count = bookings
    |> Enum.filter(fn b ->
      Date.compare(b.check_in, date) != :gt and
      (is_nil(b.check_out) or Date.compare(b.check_out, date) == :gt)
    end)
    |> Enum.map(& &1.quantity)
    |> Enum.sum()

    {date, count}
  end)
  |> Map.new()
end
````

Please answer the questions above so I can provide a complete, tailored solution for your calendar view!

---

_**User (2025-10-22 19:34Z)**_

1. use item_type
2. all groups have same weight
3. add limit of 45, hardcode it into code for now
4. total count per day and color code it against capacity limit. No breakdown

---

_**Assistant (copilot/claude-sonnet-4.5)**_

Perfect! Let me provide a complete solution for tracking occupancy with color-coded calendar display.

## Summary:
- Adding `item_type` field to `booking_invoice_items` to distinguish people from extras
- Setting cottage capacity to 45 (hardcoded)
- Color-coding days: green (plenty of space), yellow (getting full), red (at/over capacity)

## Implementation:

````elixir
defmodule CozyCheckout.Repo.Migrations.AddItemTypeToBookingInvoiceItems do
  use Ecto.Migration

  def change do
    alter table(:booking_invoice_items) do
      add :item_type, :string, default: "person", null: false
    end

    create index(:booking_invoice_items, [:item_type])
  end
end
````

````elixir
defmodule CozyCheckout.Bookings.BookingInvoiceItem do
  use Ecto.Schema
  import Ecto.Changeset

  @primary_key {:id, :binary_id, autogenerate: true}
  @foreign_key_type :binary_id
  schema "booking_invoice_items" do
    field :name, :string
    field :quantity, :integer
    field :price_per_night, :decimal
    field :vat_rate, :decimal
    field :item_type, :string, default: "person"

    # Cached calculations
    field :subtotal, :decimal
    field :vat_amount, :decimal
    field :total, :decimal

    field :position, :integer, default: 0

    belongs_to :booking_invoice, CozyCheckout.Bookings.BookingInvoice

    timestamps(type: :utc_datetime)
  end

  @doc false
  def changeset(invoice_item, attrs) do
    invoice_item
    |> cast(attrs, [
      :booking_invoice_id,
      :name,
      :quantity,
      :price_per_night,
      :vat_rate,
      :subtotal,
      :vat_amount,
      :total,
      :position,
      :item_type
    ])
    |> validate_required([:name, :quantity, :price_per_night, :vat_rate, :item_type])
    |> validate_number(:quantity, greater_than_or_equal_to: 0)
    |> validate_number(:price_per_night, greater_than_or_equal_to: 0)
    |> validate_number(:vat_rate, greater_than_or_equal_to: 0, less_than_or_equal_to: 100)
    |> validate_inclusion(:item_type, ["person", "extra"])
  end

  # ...existing code...
end
````

````elixir
defmodule CozyCheckout.Bookings do
  # ...existing code...

  @cottage_capacity 45

  @doc """
  Returns the cottage capacity limit.
  """
  def cottage_capacity, do: @cottage_capacity

  @doc """
  Returns the total number of people booked for a specific date.
  Only counts invoice items with item_type == "person".
  """
  def get_occupancy_for_date(date) do
    from(b in Booking,
      join: bi in BookingInvoice, on: bi.booking_id == b.id,
      join: bii in BookingInvoiceItem, on: bii.booking_invoice_id == bi.id,
      where: b.status in ["upcoming", "active"],
      where: b.check_in_date <= ^date,
      where: is_nil(b.check_out_date) or b.check_out_date > ^date,
      where: bii.item_type == "person",
      select: sum(bii.quantity)
    )
    |> Repo.one()
    |> case do
      nil -> 0
      count -> count
    end
  end

  @doc """
  Returns daily occupancy for a date range (for calendar view).
  Returns a map: %{~D[2025-10-22] => 12, ~D[2025-10-23] => 15, ...}
  Only counts invoice items with item_type == "person".
  """
  def get_occupancy_for_range(start_date, end_date) do
    # Get all bookings that overlap with the date range
    bookings = from(b in Booking,
      join: bi in BookingInvoice, on: bi.booking_id == b.id,
      join: bii in BookingInvoiceItem, on: bii.booking_invoice_id == bi.id,
      where: b.status in ["upcoming", "active"],
      where: b.check_in_date <= ^end_date,
      where: is_nil(b.check_out_date) or b.check_out_date > ^start_date,
      where: bii.item_type == "person",
      select: %{
        check_in: b.check_in_date,
        check_out: b.check_out_date,
        quantity: bii.quantity
      }
    )
    |> Repo.all()

    # Calculate occupancy for each day
    Date.range(start_date, end_date)
    |> Enum.map(fn date ->
      count = bookings
      |> Enum.filter(fn b ->
        Date.compare(b.check_in, date) != :gt and
        (is_nil(b.check_out) or Date.compare(b.check_out, date) == :gt)
      end)
      |> Enum.map(& &1.quantity)
      |> Enum.sum()

      {date, count}
    end)
    |> Map.new()
  end

  @doc """
  Returns the occupancy level for display purposes.
  Returns: :low (0-29), :medium (30-39), :high (40-44), :full (45+)
  """
  def occupancy_level(count) do
    cond do
      count >= @cottage_capacity -> :full
      count >= 40 -> :high
      count >= 30 -> :medium
      true -> :low
    end
  end
end
````

````elixir
defmodule CozyCheckoutWeb.Admin.BookingLive.Calendar do
  use CozyCheckoutWeb, :live_view
  alias CozyCheckout.Bookings

  # ...existing code...

  def mount(_params, _session, socket) do
    today = Date.utc_today()
    current_month = %{year: today.year, month: today.month}
    
    socket =
      socket
      |> assign(:current_month, current_month)
      |> load_calendar_data()

    {:ok, socket}
  end

  # ...existing code...

  defp load_calendar_data(socket) do
    %{year: year, month: month} = socket.assigns.current_month
    
    # Get first and last day of the month
    first_day = Date.new!(year, month, 1)
    last_day = Date.end_of_month(first_day)
    
    # Get calendar range (including days from prev/next month to fill the grid)
    calendar_start = Date.beginning_of_week(first_day, :monday)
    calendar_end = Date.end_of_week(last_day, :monday)
    
    bookings = Bookings.list_bookings_for_month(year, month)
    occupancy_map = Bookings.get_occupancy_for_range(calendar_start, calendar_end)
    capacity = Bookings.cottage_capacity()
    
    socket
    |> assign(:bookings, bookings)
    |> assign(:occupancy_map, occupancy_map)
    |> assign(:capacity, capacity)
    |> assign(:calendar_days, generate_calendar_days(first_day, calendar_start, calendar_end))
  end

  # ...existing code...

  defp occupancy_badge_class(count, capacity) do
    level = Bookings.occupancy_level(count)
    
    base_classes = "absolute top-1 right-1 text-xs font-semibold px-2 py-0.5 rounded-full"
    
    color_classes = case level do
      :full -> "bg-red-500 text-white"
      :high -> "bg-orange-500 text-white"
      :medium -> "bg-yellow-500 text-gray-900"
      :low -> "bg-green-500 text-white"
    end
    
    "#{base_classes} #{color_classes}"
  end
end
````

````elixir
<Layouts.app flash={@flash} current_scope={@current_scope}>
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
    <%!-- Header --%>
    <div class="flex items-center justify-between mb-6">
      <h1 class="text-3xl font-bold">Booking Calendar</h1>
      <.link navigate={~p"/admin/bookings/new"} class="btn btn-primary">
        New Booking
      </.link>
    </div>

    <%!-- Month navigation --%>
    <div class="flex items-center justify-between mb-6">
      <button
        phx-click="prev_month"
        class="btn btn-outline btn-sm"
      >
        ← Previous
      </button>
      
      <h2 class="text-2xl font-semibold">
        {Calendar.strftime(Date.new!(@current_month.year, @current_month.month, 1), "%B %Y")}
      </h2>
      
      <button
        phx-click="next_month"
        class="btn btn-outline btn-sm"
      >
        Next →
      </button>
    </div>

    <%!-- Capacity legend --%>
    <div class="mb-4 flex items-center gap-4 text-sm">
      <span class="font-semibold">Capacity: {@capacity} people</span>
      <div class="flex items-center gap-2">
        <span class="inline-block w-4 h-4 rounded bg-green-500"></span>
        <span>Low (0-29)</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="inline-block w-4 h-4 rounded bg-yellow-500"></span>
        <span>Medium (30-39)</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="inline-block w-4 h-4 rounded bg-orange-500"></span>
        <span>High (40-44)</span>
      </div>
      <div class="flex items-center gap-2">
        <span class="inline-block w-4 h-4 rounded bg-red-500"></span>
        <span>Full (45+)</span>
      </div>
    </div>

    <%!-- Calendar grid --%>
    <div class="bg-base-100 rounded-lg shadow overflow-hidden">
      <%!-- Day headers --%>
      <div class="grid grid-cols-7 gap-px bg-base-300">
        <%= for day_name <- ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"] do %>
          <div class="bg-base-100 p-2 text-center font-semibold text-sm">
            {day_name}
          </div>
        <% end %>
      </div>

      <%!-- Calendar days --%>
      <div class="grid grid-cols-7 gap-px bg-base-300">
        <%= for day <- @calendar_days do %>
          <div class={[
            "bg-base-100 min-h-[120px] p-2 relative",
            !day.current_month && "opacity-40"
          ]}>
            <%!-- Day number --%>
            <div class="text-sm font-semibold mb-2">
              {day.date.day}
            </div>

            <%!-- Occupancy badge --%>
            <%= if occupancy = Map.get(@occupancy_map, day.date, 0) do %>
              <%= if occupancy > 0 do %>
                <div class={occupancy_badge_class(occupancy, @capacity)}>
                  {occupancy}/{@capacity}
                </div>
              <% end %>
            <% end %>

            <%!-- Bookings for this day --%>
            <div class="space-y-1 mt-6">
              <%= for booking <- Enum.filter(@bookings, fn b ->
                Date.compare(b.check_in_date, day.date) != :gt and
                (is_nil(b.check_out_date) or Date.compare(b.check_out_date, day.date) == :gt)
              end) do %>
                <.link
                  navigate={~p"/admin/bookings/#{booking.id}"}
                  class="block text-xs p-1 bg-primary/10 hover:bg-primary/20 rounded truncate"
                >
                  {booking.primary_guest.name}
                </.link>
              <% end %>
            </div>
          </div>
        <% end %>
      </div>
    </div>
  </div>
</Layouts.app>
````

## Key Features:

1. **Item Type Field**: Separates people from extras in invoice items
2. **Occupancy Tracking**: Counts only items with `item_type == "person"`
3. **Color Coding**:
   - 🟢 Green (0-29): Plenty of space
   - 🟡 Yellow (30-39): Getting full
   - 🟠 Orange (40-44): Almost full
   - 🔴 Red (45+): At/over capacity
4. **Calendar Display**: Shows "X/45" badge on each day with color-coded background
5. **Capacity Constant**: Hardcoded at 45, easy to change later

Run `mix ecto.migrate` to apply the migration!

---

_**User (2025-10-22 19:38Z)**_

Please actually implement it now when I switched to agent mode

---

_**Assistant (copilot/claude-sonnet-4.5)**_

I'll implement the occupancy tracking feature now. Let me start by creating a migration for the `item_type` field, updating the schema, and then adding the occupancy functions to the Bookings context. 
```

```

```

```

```

```
Now let me read the Bookings context to add the occupancy functions: Now I'll add the occupancy functions to the Bookings context: 
```

```

```

```
Now let me read the calendar LiveView to update it with occupancy display: Let me search for the calendar view: Now let me update the calendar LiveView to include occupancy tracking: 
```

```

```

```

```

```
Now let me read the calendar template to add the legend: 
```

```
Now let's run the migration: Great! Now let me update the seeds file to ensure existing invoice items have the `item_type` field set: I need to add booking invoice creation to the seeds. Let me search for where booking invoices should be created: Let me add invoice creation to the seeds file after booking creation: 

---

_**User (2025-10-22 19:38Z)**_

do not add seeds. Ignore them for now. Anything else you need to do for this task?

---

_**Assistant (copilot/claude-sonnet-4.5)**_

Let me check if there are any other places where we need to update the code to handle the new `item_type` field: Good! I need to update the `create_default_invoice` function to include `item_type` in the default items: 
```

```
Now let me check the invoice component to see if we need to add a way to set the `item_type` when adding new items: Let me check the form to see if there's an `item_type` field: I need to add the `item_type` field to the invoice item forms. Let me update the invoice component: 
```

```
Now let me add the `item_type` select field to the forms in the template: 
```

```

```

```
Now let me also add a column header and display for the item_type in the table. Let me check the table headers: 
```

```

```

```
Now let me update the display mode to show the item_type: 

---

