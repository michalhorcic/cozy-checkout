<!-- Generated by SpecStory -->

<!-- vscode Session 706d08bb-f92c-41b2-9cb3-b9ca961f3609 (2025-10-16 21:24Z) -->

# Importing iCal file for guest bookings (2025-10-16 21:24Z)

_**User (2025-10-16 21:25Z)**_

#file:default.ics check this file. It is standard ical format. Would you be able to import this to our system and create guests and bookings from it?

---

_**Assistant (copilot/claude-sonnet-4.5)**_

Yes, I can help you import this iCal file into the system! The file contains VEVENT entries with booking information. Here's my plan:

## Import Strategy

1. **Parse the iCal file** - Extract guest names, dates, contact info, and notes from each VEVENT
2. **Create/find guests** - Match by name/email or create new guests
3. **Create bookings** - Create bookings with the extracted information

## Implementation

I'll create an import module and a LiveView interface for this:

````elixir
defmodule CozyCheckout.IcalImporter do
  @moduledoc """
  Imports iCal files to create guests and bookings.
  """

  alias CozyCheckout.{Guests, Bookings, Repo}
  alias CozyCheckout.Guests.Guest
  alias CozyCheckout.Bookings.Booking

  @doc """
  Imports bookings from an iCal file content.
  Returns {:ok, stats} or {:error, reason}
  """
  def import_ical(file_content) do
    with {:ok, events} <- parse_ical(file_content),
         {:ok, stats} <- process_events(events) do
      {:ok, stats}
    end
  end

  defp parse_ical(content) do
    try do
      events =
        content
        |> String.split("BEGIN:VEVENT")
        |> Enum.drop(1)
        |> Enum.map(&parse_event/1)
        |> Enum.reject(&is_nil/1)

      {:ok, events}
    rescue
      e -> {:error, "Failed to parse iCal file: #{Exception.message(e)}"}
    end
  end

  defp parse_event(event_text) do
    summary = extract_field(event_text, "SUMMARY")
    dtstart = extract_field(event_text, "DTSTART")
    dtend = extract_field(event_text, "DTEND")
    description = extract_field(event_text, "Description")
    status = extract_field(event_text, "STATUS")

    # Parse description for contact info
    {phone, email, notes} = parse_description(description)

    if summary && dtstart && dtend do
      %{
        guest_name: summary,
        check_in_date: parse_date(dtstart),
        check_out_date: parse_date(dtend),
        phone: phone,
        email: email,
        notes: notes,
        status: map_status(status)
      }
    else
      nil
    end
  end

  defp extract_field(text, field_name) do
    case Regex.run(~r/#{field_name}:(.+)/, text) do
      [_, value] -> String.trim(value)
      _ -> nil
    end
  end

  defp parse_description(nil), do: {nil, nil, nil}

  defp parse_description(desc) do
    # Unescape the description (iCal uses \, and \n for escaping)
    desc = desc |> String.replace("\\,", ",") |> String.replace("\\n", "\n")

    phone = extract_description_field(desc, "Telefon")
    email = extract_description_field(desc, "Email")

    # Extract notes (everything after the adults/children count)
    notes =
      case Regex.run(~r/Dospělí:.*?děti \d+\\n(.+)$/s, desc) do
        [_, note] -> String.trim(note)
        _ -> nil
      end

    {phone, email, notes}
  end

  defp extract_description_field(desc, field) do
    case Regex.run(~r/#{field}: ?([^\n\\]+)/, desc) do
      [_, value] ->
        value = String.trim(value)
        if value == "" or value == "\\", do: nil, else: value

      _ ->
        nil
    end
  end

  defp parse_date(date_str) do
    # Format: 20251205T140000
    case Regex.run(~r/(\d{4})(\d{2})(\d{2})/, date_str) do
      [_, year, month, day] ->
        Date.new!(String.to_integer(year), String.to_integer(month), String.to_integer(day))

      _ ->
        nil
    end
  end

  defp map_status("CONFIRMED"), do: "active"
  defp map_status("TENTATIVE"), do: "upcoming"
  defp map_status(_), do: "upcoming"

  defp process_events(events) do
    stats = %{
      guests_created: 0,
      guests_found: 0,
      bookings_created: 0,
      bookings_skipped: 0,
      errors: []
    }

    Enum.reduce(events, stats, fn event, acc ->
      process_event(event, acc)
    end)
    |> then(&{:ok, &1})
  end

  defp process_event(event, stats) do
    case find_or_create_guest(event) do
      {:ok, guest, created?} ->
        stats =
          if created? do
            Map.update!(stats, :guests_created, &(&1 + 1))
          else
            Map.update!(stats, :guests_found, &(&1 + 1))
          end

        case create_booking(guest, event) do
          {:ok, _booking} ->
            Map.update!(stats, :bookings_created, &(&1 + 1))

          {:error, reason} ->
            stats
            |> Map.update!(:bookings_skipped, &(&1 + 1))
            |> Map.update!(:errors, &[{event.guest_name, reason} | &1])
        end

      {:error, reason} ->
        stats
        |> Map.update!(:bookings_skipped, &(&1 + 1))
        |> Map.update!(:errors, &[{event.guest_name, reason} | &1])
    end
  end

  defp find_or_create_guest(event) do
    # Try to find existing guest by name or email
    guest =
      cond do
        event.email ->
          Repo.get_by(Guest, email: event.email) |> Repo.preload(:bookings)

        true ->
          Guest
          |> Ecto.Query.where([g], g.name == ^event.guest_name)
          |> Ecto.Query.where([g], is_nil(g.deleted_at))
          |> Repo.one()
          |> case do
            nil -> nil
            g -> Repo.preload(g, :bookings)
          end
      end

    case guest do
      nil ->
        # Create new guest
        case Guests.create_guest(%{
               name: event.guest_name,
               email: event.email,
               phone: event.phone
             }) do
          {:ok, guest} -> {:ok, guest, true}
          {:error, changeset} -> {:error, "Failed to create guest: #{inspect(changeset.errors)}"}
        end

      existing_guest ->
        {:ok, existing_guest, false}
    end
  end

  defp create_booking(guest, event) do
    # Check if booking already exists for this guest and dates
    existing =
      Booking
      |> Ecto.Query.where([b], b.guest_id == ^guest.id)
      |> Ecto.Query.where([b], b.check_in_date == ^event.check_in_date)
      |> Ecto.Query.where([b], is_nil(b.deleted_at))
      |> Repo.one()

    case existing do
      nil ->
        Bookings.create_booking(%{
          guest_id: guest.id,
          check_in_date: event.check_in_date,
          check_out_date: event.check_out_date,
          status: event.status,
          notes: event.notes
        })

      _existing ->
        {:error, "Booking already exists for these dates"}
    end
  end
end
````

Now let's create a LiveView interface for uploading and importing the file:

````elixir
defmodule CozyCheckoutWeb.IcalImportLive.Index do
  use CozyCheckoutWeb, :live_view

  alias CozyCheckout.IcalImporter

  @impl true
  def mount(_params, _session, socket) do
    {:ok,
     socket
     |> assign(:page_title, "Import iCal Bookings")
     |> assign(:uploaded_files, [])
     |> assign(:import_result, nil)
     |> allow_upload(:ical_file,
       accept: ~w(.ics),
       max_entries: 1,
       max_file_size: 5_000_000
     )}
  end

  @impl true
  def handle_event("validate", _params, socket) do
    {:noreply, socket}
  end

  @impl true
  def handle_event("cancel-upload", %{"ref" => ref}, socket) do
    {:noreply, cancel_upload(socket, :ical_file, ref)}
  end

  @impl true
  def handle_event("import", _params, socket) do
    uploaded_files =
      consume_uploaded_entries(socket, :ical_file, fn %{path: path}, _entry ->
        content = File.read!(path)
        {:ok, content}
      end)

    case uploaded_files do
      [content] ->
        case IcalImporter.import_ical(content) do
          {:ok, stats} ->
            {:noreply,
             socket
             |> assign(:import_result, {:ok, stats})
             |> put_flash(:info, "Import completed successfully!")}

          {:error, reason} ->
            {:noreply,
             socket
             |> assign(:import_result, {:error, reason})
             |> put_flash(:error, "Import failed: #{reason}")}
        end

      [] ->
        {:noreply, put_flash(socket, :error, "Please select a file to import")}
    end
  end

  @impl true
  def render(assigns) do
    ~H"""
    <div class="max-w-4xl mx-auto px-4 py-8">
      <div class="mb-8">
        <.link navigate={~p"/admin"} class="text-blue-600 hover:text-blue-800 mb-2 inline-block">
          ← Back to Dashboard
        </.link>
        <h1 class="text-4xl font-bold text-gray-900">{@page_title}</h1>
        <p class="text-gray-600 mt-2">
          Import bookings from an iCal (.ics) file. The system will create guests and bookings automatically.
        </p>
      </div>

      <div class="bg-white shadow-lg rounded-lg p-6">
        <form phx-submit="import" phx-change="validate" class="space-y-6">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2">
              Select iCal File
            </label>
            <div
              class="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-lg hover:border-blue-400 transition-colors"
              phx-drop-target={@uploads.ical_file.ref}
            >
              <div class="space-y-1 text-center">
                <.icon name="hero-document-arrow-up" class="mx-auto h-12 w-12 text-gray-400" />
                <div class="flex text-sm text-gray-600">
                  <label
                    for={@uploads.ical_file.ref}
                    class="relative cursor-pointer bg-white rounded-md font-medium text-blue-600 hover:text-blue-500"
                  >
                    <span>Upload a file</span>
                    <.live_file_input upload={@uploads.ical_file} class="sr-only" />
                  </label>
                  <p class="pl-1">or drag and drop</p>
                </div>
                <p class="text-xs text-gray-500">iCal files (.ics) up to 5MB</p>
              </div>
            </div>
          </div>

          <%!-- Show uploaded files --%>
          <div :for={entry <- @uploads.ical_file.entries} class="flex items-center gap-4 p-4 bg-gray-50 rounded-lg">
            <.icon name="hero-document-text" class="w-8 h-8 text-blue-600" />
            <div class="flex-1">
              <p class="text-sm font-medium text-gray-900">{entry.client_name}</p>
              <p class="text-xs text-gray-500">{format_bytes(entry.client_size)}</p>
            </div>
            <button
              type="button"
              phx-click="cancel-upload"
              phx-value-ref={entry.ref}
              class="text-red-600 hover:text-red-800"
            >
              <.icon name="hero-x-mark" class="w-5 h-5" />
            </button>
          </div>

          <%!-- Upload errors --%>
          <div :for={err <- upload_errors(@uploads.ical_file)} class="text-red-600 text-sm">
            {error_to_string(err)}
          </div>

          <div class="flex justify-end">
            <.button type="submit" disabled={@uploads.ical_file.entries == []}>
              <.icon name="hero-arrow-down-tray" class="w-5 h-5 mr-2" />
              Import Bookings
            </.button>
          </div>
        </form>
      </div>

      <%!-- Import Results --%>
      <div :if={@import_result} class="mt-6 bg-white shadow-lg rounded-lg p-6">
        <h2 class="text-2xl font-bold text-gray-900 mb-4">Import Results</h2>

        <%= case @import_result do %>
          <% {:ok, stats} -> %>
            <div class="space-y-4">
              <div class="grid grid-cols-2 gap-4">
                <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                  <p class="text-sm text-green-600 font-medium">Guests Created</p>
                  <p class="text-3xl font-bold text-green-900">{stats.guests_created}</p>
                </div>
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <p class="text-sm text-blue-600 font-medium">Guests Found</p>
                  <p class="text-3xl font-bold text-blue-900">{stats.guests_found}</p>
                </div>
                <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                  <p class="text-sm text-green-600 font-medium">Bookings Created</p>
                  <p class="text-3xl font-bold text-green-900">{stats.bookings_created}</p>
                </div>
                <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                  <p class="text-sm text-yellow-600 font-medium">Bookings Skipped</p>
                  <p class="text-3xl font-bold text-yellow-900">{stats.bookings_skipped}</p>
                </div>
              </div>

              <div :if={stats.errors != []} class="mt-4">
                <h3 class="text-lg font-semibold text-gray-900 mb-2">Errors</h3>
                <div class="bg-red-50 border border-red-200 rounded-lg p-4 space-y-2">
                  <div :for={{guest_name, error} <- stats.errors} class="text-sm text-red-800">
                    <span class="font-medium">{guest_name}:</span> {error}
                  </div>
                </div>
              </div>
            </div>
          <% {:error, reason} -> %>
            <div class="bg-red-50 border border-red-200 rounded-lg p-4">
              <p class="text-red-800">{reason}</p>
            </div>
        <% end %>
      </div>
    </div>
    """
  end

  defp error_to_string(:too_large), do: "File is too large (max 5MB)"
  defp error_to_string(:not_accepted), do: "File type not accepted (only .ics files)"
  defp error_to_string(:too_many_files), do: "Too many files (max 1)"

  defp format_bytes(bytes) do
    cond do
      bytes >= 1_000_000 -> "#{Float.round(bytes / 1_000_000, 2)} MB"
      bytes >= 1_000 -> "#{Float.round(bytes / 1_000, 2)} KB"
      true -> "#{bytes} bytes"
    end
  end
end
````

Now add the route to the router:

````elixir
# ...existing code...

scope "/admin", CozyCheckoutWeb do
  pipe_through :browser

  # ...existing admin routes...
  
  live "/ical-import", IcalImportLive.Index, :index
end

# ...existing code...
````

Finally, add a card to the dashboard:

````elixir
# ...existing code...

<.dashboard_card
  title="Import Bookings"
  description="Import from iCal file"
  icon="hero-arrow-down-tray"
  navigate={~p"/admin/ical-import"}
  color="indigo"
/>

# ...existing code...
````

## Features

This implementation:
- ✅ Parses iCal VEVENT entries
- ✅ Extracts guest name, dates, phone, email, and notes
- ✅ Creates or finds existing guests by email/name
- ✅ Creates bookings with proper status mapping
- ✅ Handles duplicates (skips existing bookings)
- ✅ Provides detailed import statistics
- ✅ Shows errors for failed imports
- ✅ Drag-and-drop file upload interface

The importer will:
1. Parse each VEVENT from the iCal file
2. Extract guest information from the SUMMARY and Description fields
3. Create new guests or find existing ones by email/name
4. Create bookings for each event
5. Skip duplicate bookings (same guest + check-in date)
6. Report statistics and errors

Would you like me to adjust any part of the import logic or add additional features?

---

_**User (2025-10-16 21:27Z)**_

Looks good. Please now implement it

---

_**Assistant (copilot/claude-sonnet-4.5)**_

I'll implement the iCal import functionality now. Let me create all the necessary files. 

---

